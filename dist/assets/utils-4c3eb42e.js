const d="contexts_db";const a=()=>new Promise((o,e)=>{const n=indexedDB.open(d,1);n.onupgradeneeded=r=>{const t=r.target.result;if(!t.objectStoreNames.contains("contexts")){const s=t.createObjectStore("contexts",{keyPath:"id",autoIncrement:!0});s.createIndex("title","title",{unique:!1}),s.createIndex("description","description",{unique:!1})}},n.onsuccess=r=>o(r.target.result),n.onerror=()=>e(new Error("Error opening IndexedDB"))}),i=async o=>{try{const e=await a(),n=e.transaction("contexts","readwrite"),r=n.objectStore("contexts"),t=r.add(o);return new Promise((s,c)=>{t.onsuccess=()=>s(),t.onerror=()=>c(new Error("Error adding context"))})}catch(e){throw console.log("Error opening IndexedDB",e),new Error("Error opening IndexedDB")}},u=async()=>{try{const o=await a(),e=o.transaction("contexts","readonly"),n=e.objectStore("contexts"),r=n.getAll();return new Promise((t,s)=>{r.onsuccess=()=>t(r.result),r.onerror=()=>s(new Error("Error fetching contexts"))})}catch(o){throw console.log("Error opening IndexedDB",o),new Error("Error opening IndexedDB")}},x=async o=>{try{const e=await a(),n=e.transaction("contexts","readwrite"),r=n.objectStore("contexts"),t=r.put(o);return new Promise((s,c)=>{t.onsuccess=()=>s(),t.onerror=()=>c(new Error("Error updating context"))})}catch(e){throw console.log("Error opening IndexedDB",e),new Error("Error opening IndexedDB")}};export{i as a,u as g,x as u};
